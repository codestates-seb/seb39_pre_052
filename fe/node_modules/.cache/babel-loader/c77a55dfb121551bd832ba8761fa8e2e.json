{"ast":null,"code":"import { getSecondsInUnit } from './units.js';\nimport { getRoundFunction, getDiffRatioToNextRoundedNumber } from '../round.js';\n/**\r\n * Gets the time to next update for a step with a time unit defined.\r\n * @param  {string} unit\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {number} options.now\r\n * @param  {string} [options.round] — (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {\n  var now = _ref.now,\n      round = _ref.round; // For some units, like \"now\", there's no defined amount of seconds in them.\n\n  if (!getSecondsInUnit(unit)) {\n    // If there's no amount of seconds defined for this unit\n    // then the update interval can't be determined reliably.\n    return;\n  }\n\n  var unitDenominator = getSecondsInUnit(unit) * 1000;\n  var future = timestamp > now;\n  var preciseAmount = Math.abs(timestamp - now);\n  var roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator;\n\n  if (future) {\n    if (roundedAmount > 0) {\n      // Amount decreases with time.\n      return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round, unitDenominator);\n    } else {\n      // Refresh right after the zero point,\n      // when \"future\" changes to \"past\".\n      return preciseAmount - roundedAmount + 1;\n    }\n  } // Amount increases with time.\n\n\n  return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator);\n}\n\nfunction getDiffToNextRoundedNumber(round, unitDenominator) {\n  return getDiffRatioToNextRoundedNumber(round) * unitDenominator;\n}\n\nfunction getDiffToPreviousRoundedNumber(round, unitDenominator) {\n  return (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1;\n}","map":{"version":3,"names":["getSecondsInUnit","getRoundFunction","getDiffRatioToNextRoundedNumber","getTimeToNextUpdateForUnit","unit","timestamp","_ref","now","round","unitDenominator","future","preciseAmount","Math","abs","roundedAmount","getDiffToPreviousRoundedNumber","getDiffToNextRoundedNumber"],"sources":["/Users/sushee/Desktop/CodeStates/pre-project/seb39_pre_052/node_modules/javascript-time-ago/modules/steps/getTimeToNextUpdateForUnit.js"],"sourcesContent":["import { getSecondsInUnit } from './units.js';\nimport { getRoundFunction, getDiffRatioToNextRoundedNumber } from '../round.js';\n/**\r\n * Gets the time to next update for a step with a time unit defined.\r\n * @param  {string} unit\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {number} options.now\r\n * @param  {string} [options.round] — (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {\n  var now = _ref.now,\n      round = _ref.round;\n\n  // For some units, like \"now\", there's no defined amount of seconds in them.\n  if (!getSecondsInUnit(unit)) {\n    // If there's no amount of seconds defined for this unit\n    // then the update interval can't be determined reliably.\n    return;\n  }\n\n  var unitDenominator = getSecondsInUnit(unit) * 1000;\n  var future = timestamp > now;\n  var preciseAmount = Math.abs(timestamp - now);\n  var roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator;\n\n  if (future) {\n    if (roundedAmount > 0) {\n      // Amount decreases with time.\n      return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round, unitDenominator);\n    } else {\n      // Refresh right after the zero point,\n      // when \"future\" changes to \"past\".\n      return preciseAmount - roundedAmount + 1;\n    }\n  } // Amount increases with time.\n\n\n  return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator);\n}\n\nfunction getDiffToNextRoundedNumber(round, unitDenominator) {\n  return getDiffRatioToNextRoundedNumber(round) * unitDenominator;\n}\n\nfunction getDiffToPreviousRoundedNumber(round, unitDenominator) {\n  return (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1;\n}\n//# sourceMappingURL=getTimeToNextUpdateForUnit.js.map"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,YAAjC;AACA,SAASC,gBAAT,EAA2BC,+BAA3B,QAAkE,aAAlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,0BAAT,CAAoCC,IAApC,EAA0CC,SAA1C,EAAqDC,IAArD,EAA2D;EACxE,IAAIC,GAAG,GAAGD,IAAI,CAACC,GAAf;EAAA,IACIC,KAAK,GAAGF,IAAI,CAACE,KADjB,CADwE,CAIxE;;EACA,IAAI,CAACR,gBAAgB,CAACI,IAAD,CAArB,EAA6B;IAC3B;IACA;IACA;EACD;;EAED,IAAIK,eAAe,GAAGT,gBAAgB,CAACI,IAAD,CAAhB,GAAyB,IAA/C;EACA,IAAIM,MAAM,GAAGL,SAAS,GAAGE,GAAzB;EACA,IAAII,aAAa,GAAGC,IAAI,CAACC,GAAL,CAASR,SAAS,GAAGE,GAArB,CAApB;EACA,IAAIO,aAAa,GAAGb,gBAAgB,CAACO,KAAD,CAAhB,CAAwBG,aAAa,GAAGF,eAAxC,IAA2DA,eAA/E;;EAEA,IAAIC,MAAJ,EAAY;IACV,IAAII,aAAa,GAAG,CAApB,EAAuB;MACrB;MACA,OAAOH,aAAa,GAAGG,aAAhB,GAAgCC,8BAA8B,CAACP,KAAD,EAAQC,eAAR,CAArE;IACD,CAHD,MAGO;MACL;MACA;MACA,OAAOE,aAAa,GAAGG,aAAhB,GAAgC,CAAvC;IACD;EACF,CAzBuE,CAyBtE;;;EAGF,OAAO,EAAEH,aAAa,GAAGG,aAAlB,IAAmCE,0BAA0B,CAACR,KAAD,EAAQC,eAAR,CAApE;AACD;;AAED,SAASO,0BAAT,CAAoCR,KAApC,EAA2CC,eAA3C,EAA4D;EAC1D,OAAOP,+BAA+B,CAACM,KAAD,CAA/B,GAAyCC,eAAhD;AACD;;AAED,SAASM,8BAAT,CAAwCP,KAAxC,EAA+CC,eAA/C,EAAgE;EAC9D,OAAO,CAAC,IAAIP,+BAA+B,CAACM,KAAD,CAApC,IAA+CC,eAA/C,GAAiE,CAAxE;AACD"},"metadata":{},"sourceType":"module"}