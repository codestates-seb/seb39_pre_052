{"ast":null,"code":"import _getTimeToNextUpdateForUnit from './getTimeToNextUpdateForUnit.js';\nimport getStepMinTime from './getStepMinTime.js';\nimport { getRoundFunction } from '../round.js'; // A thousand years is practically a metaphor for \"infinity\".\n\nvar YEAR = 365 * 24 * 60 * 60 * 1000;\nexport var INFINITY = 1000 * YEAR;\n/**\r\n * Gets the time to next update for a date and a step.\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {object} step\r\n * @param  {object} [options.previousStep]\r\n * @param  {object} [options.nextStep]\r\n * @param  {number} options.now\r\n * @param  {boolean} options.future\r\n * @param  {string} [options.round] - (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdate(date, step, _ref) {\n  var prevStep = _ref.prevStep,\n      nextStep = _ref.nextStep,\n      now = _ref.now,\n      future = _ref.future,\n      round = _ref.round;\n  var timestamp = date.getTime ? date.getTime() : date;\n\n  var getTimeToNextUpdateForUnit = function getTimeToNextUpdateForUnit(unit) {\n    return _getTimeToNextUpdateForUnit(unit, timestamp, {\n      now: now,\n      round: round\n    });\n  }; // For future dates, steps move from the last one to the first one,\n  // while for past dates, steps move from the first one to the last one,\n  // due to the fact that time flows in one direction,\n  // and future dates' interval naturally becomes smaller\n  // while past dates' interval naturally grows larger.\n  //\n  // For future dates, it's the transition\n  // from the current step to the previous step,\n  // therefore check the `minTime` of the current step.\n  //\n  // For past dates, it's the transition\n  // from the current step to the next step,\n  // therefore check the `minTime` of the next step.\n  //\n\n\n  var timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {\n    future: future,\n    now: now,\n    round: round,\n    prevStep: future ? prevStep : step // isFirstStep: future && isFirstStep\n\n  });\n\n  if (timeToStepChange === undefined) {\n    // Can't reliably determine \"time to next update\"\n    // if not all of the steps provide `minTime`.\n    return;\n  }\n\n  var timeToNextUpdate;\n\n  if (step) {\n    if (step.getTimeToNextUpdate) {\n      timeToNextUpdate = step.getTimeToNextUpdate(timestamp, {\n        getTimeToNextUpdateForUnit: getTimeToNextUpdateForUnit,\n        getRoundFunction: getRoundFunction,\n        now: now,\n        future: future,\n        round: round\n      });\n    }\n\n    if (timeToNextUpdate === undefined) {\n      // \"unit\" is now called \"formatAs\".\n      var unit = step.unit || step.formatAs;\n\n      if (unit) {\n        // For some units, like \"now\", there's no defined amount of seconds in them.\n        // In such cases, `getTimeToNextUpdateForUnit()` returns `undefined`,\n        // and the next step's `minTime` could be used to calculate the update interval:\n        // it will just assume that the label never changes for this step.\n        timeToNextUpdate = getTimeToNextUpdateForUnit(unit);\n      }\n    }\n  }\n\n  if (timeToNextUpdate === undefined) {\n    return timeToStepChange;\n  }\n\n  return Math.min(timeToNextUpdate, timeToStepChange);\n}\nexport function getStepChangesAt(currentOrNextStep, timestamp, _ref2) {\n  var now = _ref2.now,\n      future = _ref2.future,\n      round = _ref2.round,\n      prevStep = _ref2.prevStep; // The first step's `minTime` is `0` by default.\n  // It doesn't \"change\" steps at zero point\n  // but it does change the wording when switching\n  // from \"future\" to \"past\": \"in ...\" -> \"... ago\".\n  // Therefore, the label should be updated at zero-point too.\n\n  var minTime = getStepMinTime(currentOrNextStep, {\n    timestamp: timestamp,\n    now: now,\n    future: future,\n    round: round,\n    prevStep: prevStep\n  });\n\n  if (minTime === undefined) {\n    return;\n  }\n\n  if (future) {\n    // The step changes to the previous step\n    // as soon as `timestamp - now` becomes\n    // less than the `minTime` of the current step:\n    // `timestamp - now === minTime - 1`\n    // => `now === timestamp - minTime + 1`.\n    return timestamp - minTime * 1000 + 1;\n  } else {\n    // The step changes to the next step\n    // as soon as `now - timestamp` becomes\n    // equal to `minTime` of the next step:\n    // `now - timestamp === minTime`\n    // => `now === timestamp + minTime`.\n    // This is a special case when double-update could be skipped.\n    if (minTime === 0 && timestamp === now) {\n      return INFINITY;\n    }\n\n    return timestamp + minTime * 1000;\n  }\n}\nexport function getTimeToStepChange(step, timestamp, _ref3) {\n  var now = _ref3.now,\n      future = _ref3.future,\n      round = _ref3.round,\n      prevStep = _ref3.prevStep;\n\n  if (step) {\n    var stepChangesAt = getStepChangesAt(step, timestamp, {\n      now: now,\n      future: future,\n      round: round,\n      prevStep: prevStep\n    });\n\n    if (stepChangesAt === undefined) {\n      return;\n    }\n\n    return stepChangesAt - now;\n  } else {\n    if (future) {\n      // No step.\n      // Update right after zero point, when it changes from \"future\" to \"past\".\n      return timestamp - now + 1;\n    } else {\n      // The last step doesn't ever change when `date` is in the past.\n      return INFINITY;\n    }\n  }\n}","map":{"version":3,"names":["_getTimeToNextUpdateForUnit","getStepMinTime","getRoundFunction","YEAR","INFINITY","getTimeToNextUpdate","date","step","_ref","prevStep","nextStep","now","future","round","timestamp","getTime","getTimeToNextUpdateForUnit","unit","timeToStepChange","getTimeToStepChange","undefined","timeToNextUpdate","formatAs","Math","min","getStepChangesAt","currentOrNextStep","_ref2","minTime","_ref3","stepChangesAt"],"sources":["/Users/sushee/Desktop/CodeStates/pre-project/seb39_pre_052/node_modules/javascript-time-ago/modules/steps/getTimeToNextUpdate.js"],"sourcesContent":["import _getTimeToNextUpdateForUnit from './getTimeToNextUpdateForUnit.js';\nimport getStepMinTime from './getStepMinTime.js';\nimport { getRoundFunction } from '../round.js'; // A thousand years is practically a metaphor for \"infinity\".\n\nvar YEAR = 365 * 24 * 60 * 60 * 1000;\nexport var INFINITY = 1000 * YEAR;\n/**\r\n * Gets the time to next update for a date and a step.\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {object} step\r\n * @param  {object} [options.previousStep]\r\n * @param  {object} [options.nextStep]\r\n * @param  {number} options.now\r\n * @param  {boolean} options.future\r\n * @param  {string} [options.round] - (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdate(date, step, _ref) {\n  var prevStep = _ref.prevStep,\n      nextStep = _ref.nextStep,\n      now = _ref.now,\n      future = _ref.future,\n      round = _ref.round;\n  var timestamp = date.getTime ? date.getTime() : date;\n\n  var getTimeToNextUpdateForUnit = function getTimeToNextUpdateForUnit(unit) {\n    return _getTimeToNextUpdateForUnit(unit, timestamp, {\n      now: now,\n      round: round\n    });\n  }; // For future dates, steps move from the last one to the first one,\n  // while for past dates, steps move from the first one to the last one,\n  // due to the fact that time flows in one direction,\n  // and future dates' interval naturally becomes smaller\n  // while past dates' interval naturally grows larger.\n  //\n  // For future dates, it's the transition\n  // from the current step to the previous step,\n  // therefore check the `minTime` of the current step.\n  //\n  // For past dates, it's the transition\n  // from the current step to the next step,\n  // therefore check the `minTime` of the next step.\n  //\n\n\n  var timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {\n    future: future,\n    now: now,\n    round: round,\n    prevStep: future ? prevStep : step // isFirstStep: future && isFirstStep\n\n  });\n\n  if (timeToStepChange === undefined) {\n    // Can't reliably determine \"time to next update\"\n    // if not all of the steps provide `minTime`.\n    return;\n  }\n\n  var timeToNextUpdate;\n\n  if (step) {\n    if (step.getTimeToNextUpdate) {\n      timeToNextUpdate = step.getTimeToNextUpdate(timestamp, {\n        getTimeToNextUpdateForUnit: getTimeToNextUpdateForUnit,\n        getRoundFunction: getRoundFunction,\n        now: now,\n        future: future,\n        round: round\n      });\n    }\n\n    if (timeToNextUpdate === undefined) {\n      // \"unit\" is now called \"formatAs\".\n      var unit = step.unit || step.formatAs;\n\n      if (unit) {\n        // For some units, like \"now\", there's no defined amount of seconds in them.\n        // In such cases, `getTimeToNextUpdateForUnit()` returns `undefined`,\n        // and the next step's `minTime` could be used to calculate the update interval:\n        // it will just assume that the label never changes for this step.\n        timeToNextUpdate = getTimeToNextUpdateForUnit(unit);\n      }\n    }\n  }\n\n  if (timeToNextUpdate === undefined) {\n    return timeToStepChange;\n  }\n\n  return Math.min(timeToNextUpdate, timeToStepChange);\n}\nexport function getStepChangesAt(currentOrNextStep, timestamp, _ref2) {\n  var now = _ref2.now,\n      future = _ref2.future,\n      round = _ref2.round,\n      prevStep = _ref2.prevStep;\n  // The first step's `minTime` is `0` by default.\n  // It doesn't \"change\" steps at zero point\n  // but it does change the wording when switching\n  // from \"future\" to \"past\": \"in ...\" -> \"... ago\".\n  // Therefore, the label should be updated at zero-point too.\n  var minTime = getStepMinTime(currentOrNextStep, {\n    timestamp: timestamp,\n    now: now,\n    future: future,\n    round: round,\n    prevStep: prevStep\n  });\n\n  if (minTime === undefined) {\n    return;\n  }\n\n  if (future) {\n    // The step changes to the previous step\n    // as soon as `timestamp - now` becomes\n    // less than the `minTime` of the current step:\n    // `timestamp - now === minTime - 1`\n    // => `now === timestamp - minTime + 1`.\n    return timestamp - minTime * 1000 + 1;\n  } else {\n    // The step changes to the next step\n    // as soon as `now - timestamp` becomes\n    // equal to `minTime` of the next step:\n    // `now - timestamp === minTime`\n    // => `now === timestamp + minTime`.\n    // This is a special case when double-update could be skipped.\n    if (minTime === 0 && timestamp === now) {\n      return INFINITY;\n    }\n\n    return timestamp + minTime * 1000;\n  }\n}\nexport function getTimeToStepChange(step, timestamp, _ref3) {\n  var now = _ref3.now,\n      future = _ref3.future,\n      round = _ref3.round,\n      prevStep = _ref3.prevStep;\n\n  if (step) {\n    var stepChangesAt = getStepChangesAt(step, timestamp, {\n      now: now,\n      future: future,\n      round: round,\n      prevStep: prevStep\n    });\n\n    if (stepChangesAt === undefined) {\n      return;\n    }\n\n    return stepChangesAt - now;\n  } else {\n    if (future) {\n      // No step.\n      // Update right after zero point, when it changes from \"future\" to \"past\".\n      return timestamp - now + 1;\n    } else {\n      // The last step doesn't ever change when `date` is in the past.\n      return INFINITY;\n    }\n  }\n}\n//# sourceMappingURL=getTimeToNextUpdate.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}