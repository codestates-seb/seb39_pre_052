{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport getStepDenominator from './getStepDenominator.js';\nimport getStepMinTime from './getStepMinTime.js';\nimport { getRoundFunction } from '../round.js';\n/**\r\n * Finds an appropriate `step` of `steps` for the time interval (in seconds).\r\n *\r\n * @param {Object[]} steps - Time formatting steps.\r\n *\r\n * @param {number} secondsPassed - Time interval (in seconds).\r\n *                                 `< 0` for past dates and `> 0` for future dates.\r\n *\r\n * @param {number} options.now - Current timestamp.\r\n *\r\n * @param {boolean} [options.future] - Whether the date should be formatted as a future one\r\n *                                     instead of a past one.\r\n *\r\n * @param {string} [options.round] - (undocumented) Rounding mechanism.\r\n *\r\n * @param {string[]} [options.units] - A list of allowed time units.\r\n *                                     (Example: ['second', 'minute', 'hour', …])\r\n *\r\n * @param {boolean} [options.getNextStep] - Pass true to return `[step, nextStep]` instead of just `step`.\r\n *\r\n * @return {Object|Object[]} [step] — Either a `step` or `[prevStep, step, nextStep]`.\r\n */\n\nexport default function getStep(steps, secondsPassed, _ref) {\n  var now = _ref.now,\n      future = _ref.future,\n      round = _ref.round,\n      units = _ref.units,\n      getNextStep = _ref.getNextStep; // Ignore steps having not-supported time units in `formatAs`.\n\n  steps = filterStepsByUnits(steps, units);\n\n  var step = _getStep(steps, secondsPassed, {\n    now: now,\n    future: future,\n    round: round\n  });\n\n  if (getNextStep) {\n    if (step) {\n      var prevStep = steps[steps.indexOf(step) - 1];\n      var nextStep = steps[steps.indexOf(step) + 1];\n      return [prevStep, step, nextStep];\n    }\n\n    return [undefined, undefined, steps[0]];\n  }\n\n  return step;\n}\n\nfunction _getStep(steps, secondsPassed, _ref2) {\n  var now = _ref2.now,\n      future = _ref2.future,\n      round = _ref2.round; // If no steps fit the conditions then return nothing.\n\n  if (steps.length === 0) {\n    return;\n  } // Find the most appropriate step.\n\n\n  var i = getStepIndex(steps, secondsPassed, {\n    now: now,\n    future: future || secondsPassed < 0,\n    round: round\n  }); // If no step is applicable the return nothing.\n\n  if (i === -1) {\n    return;\n  }\n\n  var step = steps[i]; // Apply granularity to the time amount\n  // (and fall back to the previous step\n  //  if the first level of granularity\n  //  isn't met by this amount)\n\n  if (step.granularity) {\n    // Recalculate the amount of seconds passed based on `granularity`.\n    var secondsPassedGranular = getRoundFunction(round)(Math.abs(secondsPassed) / getStepDenominator(step) / step.granularity) * step.granularity; // If the granularity for this step is too high,\n    // then fall back to the previous step.\n    // (if there is any previous step)\n\n    if (secondsPassedGranular === 0 && i > 0) {\n      return steps[i - 1];\n    }\n  }\n\n  return step;\n}\n/**\r\n * Iterates through steps until it finds the maximum one satisfying the `minTime` threshold.\r\n * @param  {Object} steps - Steps.\r\n * @param  {number} secondsPassed - How much seconds have passed since the date till `now`.\r\n * @param  {number} options.now - Current timestamp.\r\n * @param  {boolean} options.future - Whether the time interval should be formatted as a future one.\r\n * @param  {number} [i] - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\n\n\nfunction getStepIndex(steps, secondsPassed, options) {\n  var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var minTime = getStepMinTime(steps[i], _objectSpread({\n    prevStep: steps[i - 1],\n    timestamp: options.now - secondsPassed * 1000\n  }, options)); // If `minTime` isn't defined or deduceable for this step, then stop.\n\n  if (minTime === undefined) {\n    return i - 1;\n  } // If the `minTime` threshold for moving from previous step\n  // to this step is too high then return the previous step.\n\n\n  if (Math.abs(secondsPassed) < minTime) {\n    return i - 1;\n  } // If it's the last step then return it.\n\n\n  if (i === steps.length - 1) {\n    return i;\n  } // Move to the next step.\n\n\n  return getStepIndex(steps, secondsPassed, options, i + 1);\n}\n/**\r\n * Leaves only allowed steps.\r\n * @param  {Object[]} steps\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\n\n\nfunction filterStepsByUnits(steps, units) {\n  return steps.filter(function (_ref3) {\n    var unit = _ref3.unit,\n        formatAs = _ref3.formatAs; // \"unit\" is now called \"formatAs\".\n\n    unit = unit || formatAs; // If this step has a `unit` defined\n    // then this `unit` must be in the list of allowed `units`.\n\n    if (unit) {\n      return units.indexOf(unit) >= 0;\n    } // A step is not required to specify a `unit`:\n    // alternatively, it could specify `format()`.\n    // (see \"twitter\" style for an example)\n\n\n    return true;\n  });\n}","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","getStepDenominator","getStepMinTime","getRoundFunction","getStep","steps","secondsPassed","_ref","now","future","round","units","getNextStep","filterStepsByUnits","step","_getStep","prevStep","indexOf","nextStep","undefined","_ref2","getStepIndex","granularity","secondsPassedGranular","Math","abs","options","minTime","timestamp","_ref3","unit","formatAs"],"sources":["/Users/sushee/Desktop/CodeStates/pre-project/seb39_pre_052/node_modules/javascript-time-ago/modules/steps/getStep.js"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport getStepDenominator from './getStepDenominator.js';\nimport getStepMinTime from './getStepMinTime.js';\nimport { getRoundFunction } from '../round.js';\n/**\r\n * Finds an appropriate `step` of `steps` for the time interval (in seconds).\r\n *\r\n * @param {Object[]} steps - Time formatting steps.\r\n *\r\n * @param {number} secondsPassed - Time interval (in seconds).\r\n *                                 `< 0` for past dates and `> 0` for future dates.\r\n *\r\n * @param {number} options.now - Current timestamp.\r\n *\r\n * @param {boolean} [options.future] - Whether the date should be formatted as a future one\r\n *                                     instead of a past one.\r\n *\r\n * @param {string} [options.round] - (undocumented) Rounding mechanism.\r\n *\r\n * @param {string[]} [options.units] - A list of allowed time units.\r\n *                                     (Example: ['second', 'minute', 'hour', …])\r\n *\r\n * @param {boolean} [options.getNextStep] - Pass true to return `[step, nextStep]` instead of just `step`.\r\n *\r\n * @return {Object|Object[]} [step] — Either a `step` or `[prevStep, step, nextStep]`.\r\n */\n\nexport default function getStep(steps, secondsPassed, _ref) {\n  var now = _ref.now,\n      future = _ref.future,\n      round = _ref.round,\n      units = _ref.units,\n      getNextStep = _ref.getNextStep;\n  // Ignore steps having not-supported time units in `formatAs`.\n  steps = filterStepsByUnits(steps, units);\n\n  var step = _getStep(steps, secondsPassed, {\n    now: now,\n    future: future,\n    round: round\n  });\n\n  if (getNextStep) {\n    if (step) {\n      var prevStep = steps[steps.indexOf(step) - 1];\n      var nextStep = steps[steps.indexOf(step) + 1];\n      return [prevStep, step, nextStep];\n    }\n\n    return [undefined, undefined, steps[0]];\n  }\n\n  return step;\n}\n\nfunction _getStep(steps, secondsPassed, _ref2) {\n  var now = _ref2.now,\n      future = _ref2.future,\n      round = _ref2.round;\n\n  // If no steps fit the conditions then return nothing.\n  if (steps.length === 0) {\n    return;\n  } // Find the most appropriate step.\n\n\n  var i = getStepIndex(steps, secondsPassed, {\n    now: now,\n    future: future || secondsPassed < 0,\n    round: round\n  }); // If no step is applicable the return nothing.\n\n  if (i === -1) {\n    return;\n  }\n\n  var step = steps[i]; // Apply granularity to the time amount\n  // (and fall back to the previous step\n  //  if the first level of granularity\n  //  isn't met by this amount)\n\n  if (step.granularity) {\n    // Recalculate the amount of seconds passed based on `granularity`.\n    var secondsPassedGranular = getRoundFunction(round)(Math.abs(secondsPassed) / getStepDenominator(step) / step.granularity) * step.granularity; // If the granularity for this step is too high,\n    // then fall back to the previous step.\n    // (if there is any previous step)\n\n    if (secondsPassedGranular === 0 && i > 0) {\n      return steps[i - 1];\n    }\n  }\n\n  return step;\n}\n/**\r\n * Iterates through steps until it finds the maximum one satisfying the `minTime` threshold.\r\n * @param  {Object} steps - Steps.\r\n * @param  {number} secondsPassed - How much seconds have passed since the date till `now`.\r\n * @param  {number} options.now - Current timestamp.\r\n * @param  {boolean} options.future - Whether the time interval should be formatted as a future one.\r\n * @param  {number} [i] - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\n\n\nfunction getStepIndex(steps, secondsPassed, options) {\n  var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var minTime = getStepMinTime(steps[i], _objectSpread({\n    prevStep: steps[i - 1],\n    timestamp: options.now - secondsPassed * 1000\n  }, options)); // If `minTime` isn't defined or deduceable for this step, then stop.\n\n  if (minTime === undefined) {\n    return i - 1;\n  } // If the `minTime` threshold for moving from previous step\n  // to this step is too high then return the previous step.\n\n\n  if (Math.abs(secondsPassed) < minTime) {\n    return i - 1;\n  } // If it's the last step then return it.\n\n\n  if (i === steps.length - 1) {\n    return i;\n  } // Move to the next step.\n\n\n  return getStepIndex(steps, secondsPassed, options, i + 1);\n}\n/**\r\n * Leaves only allowed steps.\r\n * @param  {Object[]} steps\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\n\n\nfunction filterStepsByUnits(steps, units) {\n  return steps.filter(function (_ref3) {\n    var unit = _ref3.unit,\n        formatAs = _ref3.formatAs;\n    // \"unit\" is now called \"formatAs\".\n    unit = unit || formatAs; // If this step has a `unit` defined\n    // then this `unit` must be in the list of allowed `units`.\n\n    if (unit) {\n      return units.indexOf(unit) >= 0;\n    } // A step is not required to specify a `unit`:\n    // alternatively, it could specify `format()`.\n    // (see \"twitter\" style for an example)\n\n\n    return true;\n  });\n}\n//# sourceMappingURL=getStep.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module"}